# 목표 요약

* 장르: 로그라이트 "총알지옥" 웨이브 생존 + 파밍 → 시너지 빌드 → 강한 성장 체감.
* 환경 제약: 오프라인, 서버 불가, 외부 라이브러리 불가, PC 브라우저, file:// 실행. 단일 HTML 또는 HTML + 전역 JS 몇 장.
* 기술: Canvas 2D, 쿼드트리 충돌, 시드 기반 RNG, 로컬 저장(localStorage + 수동 JSON 내보내기).

---

# 개발 흐름 전체도

1. **MVP 스펙 확정** → 2) **프로젝트 골격**(index.html + game.global.js) → 3) **게임 루프/타임스텝** → 4) **시드 RNG** → 5) **엔티티/풀** → 6) **쿼드트리 충돌** → 7) **입력/플레이어/탄/적** → 8) **웨이브·난이도 커브** → 9) **파밍·아이템·시너지** → 10) **UI/HUD/피드백** → 11) **세이브/로딩** → 12) **디버그/최적화**.

---

# 1. MVP 스펙

* 10분 러닝타임. 1분마다 웨이브 강화.
* 플레이어 WASD 이동, 마우스 조준·좌클릭 사격.
* 적은 스폰 포인트에서 출현, 패턴 탄막 발사.
* 히트 시 무적 프레임 0.6s, 노크백 없음.
* 드랍: 코어(경험치), 모듈(패시브), 칩(능력 강화 선택지). 레벨업 때 3개 중 1개 선택.
* 시너지: 태그 기반(예: [탄속], [관통], [전기], [출혈]) 조합 보너스.
* 저장: 마지막 시드, 최고 웨이브, 언락.

---

# 2. 프로젝트 구조

```
/roguelite-bullethell/
  index.html            # 더블클릭 실행
  src/
    game.global.js      # IIFE, window.Game 네임스페이스
    assets/             # 이미지가 있다면 로컬 포함(선택)
```

배포 시 가능한 한 **index.html 하나**로 병합도 고려.

---

# 3. 게임 루프와 타임스텝

* **requestAnimationFrame** 사용. 논리 업데이트는 **고정 Δt(= 1/60s)** 권장. 누적기(accumulator)로 프레임 변동 흡수.
* 순서: 입력 → 스폰/AI → 물리/충돌 → 생명주기 정리 → 렌더 → HUD.

의사코드:

```
let acc=0, last=performance.now();
function frame(now){
  acc += Math.min(0.25, (now-last)/1000); last=now;
  while(acc >= FIXED_DT){ update(FIXED_DT); acc -= FIXED_DT; }
  render(); requestAnimationFrame(frame);
}
```

---

# 4. 시드 기반 RNG

* 재현성 필요. **xorshift32** 또는 **Mulberry32** 추천. 빠르고 간단.
* 시드는 run 시작 시 고정. 저장에도 포함.

예) xorshift32:

```
function XorShift32(seed){
  let x = seed|0 || 123456789;
  return function(){
    x ^= x << 13; x ^= x >>> 17; x ^= x << 5; // 32-bit wrap
    return ((x>>>0) / 4294967296);
  };
}
```

유틸:

```
const RNG = {
  uniform: (r)=>r(),
  range: (r, a, b)=>a + (b-a)*r(),
  int: (r, a, b)=> (a + Math.floor((b-a+1)*r()))|0,
  pick: (r, arr)=> arr[(arr.length*r())|0],
  chance: (r, p)=> r() < p
};
```

---

# 5. 엔티티, 컴포넌트, 풀(Pool)

* 간단한 **ECS-lite** 또는 태그형 구조. 객체 생성/소멸 비용을 줄이기 위해 **객체 풀** 필수.
* 공통 필드: id, alive, x,y, vx,vy, r(반경), team, hp, maxHp, sprite(optional), flags.

풀 예시:

```
function Pool(factory, size){
  const a = new Array(size).fill(0).map(()=>factory());
  const free = a.slice();
  return {
    get(){ return free.length? (free.pop().alive=true, arguments[0]||a[0], a.find(o=>o.alive && !o._locked)) : null; },
    spawn(init){ if(!free.length) return null; const o = free.pop(); init(o); o.alive=true; return o; },
    release(o){ o.alive=false; free.push(o); },
    each(fn){ for(const o of a) if(o.alive) fn(o); },
    raw:a
  };
}
```

(실구현은 아래 스타터 코드 참고)

---

# 6. 쿼드트리 충돌

* 월드 AABB 기준 4분할. 노드 용량 예: 8~16. 프레임마다 **재구축보단 재삽입** 간단 구현.
* 충돌 후보군: 탄 vs 적, 적탄 vs 플레이어, 플레이어 vs 드랍.

구조:

```
class Quad{
  constructor(x,y,w,h,cap=8,depth=0,maxDepth=6){...}
  insert(item){...}
  query(range, out){...} // range: {x,y,w,h}
  clear(){...}
}
```

* 원형 충돌은 **원-원 거리 제곱** 비교로 비용 절감.

---

# 7. 입력/플레이어/탄/적 기본

* 입력: 키보드(WASD), 마우스 위치, 버튼.
* 플레이어 이동 속도 고정. 화면 경계 클램프.
* 총알: 속도, 수명, 관통 수치.
* 적: 간단한 패턴부터(직선 돌진, 부채꼴 사격, 나선 발사).

패턴 생성은 RNG와 **시드 페이즈**를 결합하면 재현 가능:

* 예: 나선 θ += ω*dt, N발을 등간격 회전 오프셋.

---

# 8. 웨이브·난이도 커브

* 시간 t에 따른 **HP, 수, 속도** 증가:

```
HP = baseHP * (1 + a*t)
Count = baseCount * (1 + b*t)
Speed = baseSpeed * (1 + c*sqrt(t))
DropRate = clamp(minDrop + d/(1+e*t), minDrop, maxDrop)
```

* 60초마다 보스/엘리트 스폰, 패턴 다단.

---

# 9. 파밍·아이템·시너지 설계

* **태그 기반 속성**으로 조합 보너스. 예: [관통]+[전기] ⇒ 관통 시 전기사슬 확률.
* 아이템 구조:

```
{
  id:"pierce_core", name:"관통 코어", tags:["관통","탄환"],
  mods:[ {stat:"pierce", add: +1}, {stat:"bulletSize", mul:0.9} ],
  synergy:[ {need:["관통","전기"], effect:"chain_on_pierce", p:0.2} ]
}
```

* 레벨업 시 **3중 선택**: 시드는 레벨과 런 시드로 결정하여 재현성.

---

# 10. UI/HUD/피드백

* 좌상단 HP, 경험치, 레벨, 웨이브 타이머.
* 좌하단 FPS, 엔티티 수, GC 카운터(디버그 토글).
* 피격 시 짧은 화면 튕김, bullet graze 점수(근접 스치기).

---

# 11. 저장/불러오기

* `localStorage.setItem('rbh_save', JSON.stringify(state))`
* Export/Import 버튼으로 JSON 텍스트 복사/붙여넣기.
* 저장 항목: 언락, 최고 웨이브/점수, 옵션, 최근 시드.

---

# 12. 성능 체크리스트

* 객체 재사용(풀), 배열 스캔 최소화.
* 충돌은 **쿼드트리 후보군**만 원형 판정.
* 캔버스 드로우 호출 최소화. 기본 도형 우선, 스프라이트는 스프라이트시트.
* 매 프레임 `new` 금지. 문자열 연결·Intl·toFixed 지양.
* 난수/삼각함수 호출 캐싱. 각도 누적.

---

# 스타터 코드

아래는 **동작하는 최소 틀**입니다. index.html과 src/game.global.js 두 파일로 시작하세요.

## index.html

```html
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Roguelite Bullet Hell</title>
  <style>
    html,body{margin:0;background:#0b0e13;color:#d0d6e0;font:14px/1.4 system-ui}
    #ui{position:fixed;left:8px;top:8px}
    #hud{position:fixed;left:8px;bottom:8px;opacity:.8}
    canvas{display:block;margin:0 auto; background:#10141c; image-rendering:pixelated}
    button{background:#1b2330;color:#e5ecf6;border:1px solid #31415a;border-radius:8px;padding:6px 10px}
  </style>
</head>
<body>
  <div id="ui">
    <button id="btnStart">게임 시작</button>
    <button id="btnExport">내보내기</button>
    <button id="btnImport">불러오기</button>
    <span id="info"></span>
  </div>
  <canvas id="game" width="960" height="540"></canvas>
  <pre id="hud"></pre>
  <script src="src/game.global.js"></script>
</body>
</html>
```

## src/game.global.js

```js
(function(){
  const Game = window.Game = {};
  // ====== Config ======
  const W=960,H=540,FIXED_DT=1/60;

  // ====== RNG ======
  function XorShift32(seed){ let x = seed|0 || 123456789; return function(){ x^=x<<13; x^=x>>>17; x^=x<<5; return (x>>>0)/4294967296; }; }
  const RNG = { range:(r,a,b)=>a+(b-a)*r(), int:(r,a,b)=> a+((b-a+1)*r()|0), pick:(r,arr)=>arr[(arr.length*r())|0], chance:(r,p)=> r()<p };

  // ====== Input ======
  const Input={ k:{}, mx:0,my:0, m:false };
  addEventListener('keydown',e=>Input.k[e.code]=true);
  addEventListener('keyup',e=>Input.k[e.code]=false);
  addEventListener('mousedown',()=>Input.m=true);
  addEventListener('mouseup',()=>Input.m=false);

  // ====== Canvas ======
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  cvs.addEventListener('mousemove',e=>{ const r=cvs.getBoundingClientRect(); Input.mx=e.clientX-r.left; Input.my=e.clientY-r.top; });

  // ====== Math util ======
  const TAU = Math.PI*2; const clamp=(v,a,b)=> v<a?a: v>b?b:v;

  // ====== Pool ======
  function makePool(factory, size){
    const raw=new Array(size); const free=[];
    for(let i=0;i<size;i++){ raw[i]=factory(); raw[i]._poolIndex=i; raw[i].alive=false; free.push(raw[i]); }
    return {
      spawn(init){ if(!free.length) return null; const o=free.pop(); init(o); o.alive=true; return o; },
      release(o){ if(!o.alive) return; o.alive=false; free.push(o); },
      each(fn){ for(const o of raw) if(o.alive) fn(o); },
      raw, free
    };
  }

  // ====== Quadtree ======
  class Quad{
    constructor(x,y,w,h,cap=12,depth=0,maxDepth=6){ Object.assign(this,{x,y,w,h,cap,depth,maxDepth}); this.items=[]; this.divided=false; }
    _sub(){ const {x,y,w,h,depth,maxDepth,cap}=this; const hw=w/2, hh=h/2; this.nw=new Quad(x,y,hw,hh,cap,depth+1,maxDepth); this.ne=new Quad(x+hw,y,hw,hh,cap,depth+1,maxDepth); this.sw=new Quad(x,y+hh,hw,hh,cap,depth+1,maxDepth); this.se=new Quad(x+hw,y+hh,hw,hh,cap,depth+1,maxDepth); this.divided=true; }
    _contains(a, o){ return o.x>=a.x && o.x<a.x+a.w && o.y>=a.y && o.y<a.y+a.h; }
    insert(o){ if(!this._contains(this,o)) return false; if(this.items.length<this.cap || this.depth>=this.maxDepth){ this.items.push(o); return true; }
      if(!this.divided) this._sub(); return this.nw.insert(o)||this.ne.insert(o)||this.sw.insert(o)||this.se.insert(o);
    }
    query(range, out){ if(!(range.x>this.x+this.w || range.x+range.w<this.x || range.y>this.y+this.h || range.y+range.h<this.y)){
        for(const it of this.items) if(it.alive && it.x>=range.x && it.x<range.x+range.w && it.y>=range.y && it.y<range.y+range.h) out.push(it);
        if(this.divided){ this.nw.query(range,out); this.ne.query(range,out); this.sw.query(range,out); this.se.query(range,out); }
      }
      return out;
    }
    clear(){ this.items.length=0; if(this.divided){ this.nw.clear(); this.ne.clear(); this.sw.clear(); this.se.clear(); this.divided=false; }
    }
  }

  // ====== Entities ======
  const bullets = makePool(()=>({type:'b',alive:false,x:0,y:0,vx:0,vy:0,r:3,life:0,team:1,pierce:0, dmg:1}), 4000);
  const enemies = makePool(()=>({type:'e',alive:false,x:0,y:0,vx:0,vy:0,r:12,hp:3,maxHp:3,t:0}), 800);
  const drops   = makePool(()=>({type:'d',alive:false,x:0,y:0,vx:0,vy:0,r:6,kind:'xp'}), 400);
  const player = {x:W/2,y:H/2,r:10,hp:5,maxHp:5, ifr:0, fireCD:0, speed:210, dmg:1, pierce:0};

  // ====== State ======
  const state = { seed: Date.now()|0, r:null, time:0, wave:1, xp:0, lvl:1, nextLvl:10, alive:true, score:0 };
  state.r = XorShift32(state.seed);

  // ====== Systems ======
  function update(dt){ if(!state.alive) return; state.time+=dt; spawnSystem(dt); inputSystem(dt); bulletSystem(dt); enemySystem(dt); collisionSystem(); cleanupSystem(); }

  function inputSystem(dt){
    const ax = (Input.k['KeyD']?1:0) - (Input.k['KeyA']?1:0);
    const ay = (Input.k['KeyS']?1:0) - (Input.k['KeyW']?1:0);
    const len = Math.hypot(ax,ay)||1; player.x = clamp(player.x + (ax/len)*player.speed*dt, player.r, W-player.r);
    player.y = clamp(player.y + (ay/len)*player.speed*dt, player.r, H-player.r);

    // fire
    player.fireCD -= dt;
    if(Input.m && player.fireCD<=0){
      const dx = Input.mx - player.x, dy = Input.my - player.y; const L = Math.hypot(dx,dy)||1; const sp=420;
      bullets.spawn(o=>{ o.x=player.x; o.y=player.y; o.vx=dx/L*sp; o.vy=dy/L*sp; o.life=1.4; o.team=0; o.pierce=player.pierce; o.dmg=player.dmg; });
      player.fireCD = 0.12;
    }
    if(player.ifr>0) player.ifr-=dt;
  }

  function bulletSystem(dt){
    bullets.each(o=>{ o.x+=o.vx*dt; o.y+=o.vy*dt; o.life-=dt; if(o.x<-20||o.x>W+20||o.y<-20||o.y>H+20||o.life<=0) bullets.release(o); });
  }

  function enemySystem(dt){
    // simple spawner scaling with time
    if(state.time<600){
      // every 0.6s spawn small pack
      if(((state.time*10)|0)!==(((state.time-dt)*10)|0)) {
        const n = 3 + ((state.time/20)|0);
        for(let i=0;i<n;i++) spawnEnemy();
      }
    }
    enemies.each(e=>{
      e.t+=dt; // orbit move
      const sp = 40 + Math.min(140, state.time*0.8);
      const dx = player.x - e.x, dy = player.y - e.y; const L=Math.hypot(dx,dy)||1;
      e.vx = dx/L*sp; e.vy = dy/L*sp; e.x+=e.vx*dt; e.y+=e.vy*dt;
      // fire spiral
      if(((e.t*4)|0)!==(((e.t-dt)*4)|0)){
        const k=6; const base = e.t*TAU*0.13;
        for(let j=0;j<k;j++){
          const a = base + j*(TAU/k);
          bullets.spawn(b=>{ b.x=e.x; b.y=e.y; b.vx=Math.cos(a)*120; b.vy=Math.sin(a)*120; b.life=3; b.team=1; b.r=3; });
        }
      }
    });
  }

  function spawnEnemy(){
    const side = RNG.int(state.r,0,3);
    let x=0,y=0; if(side===0){x=RNG.range(state.r,0,W); y=-16;}else if(side===1){x=W+16; y=RNG.range(state.r,0,H);}else if(side===2){x=RNG.range(state.r,0,W); y=H+16;}else{ x=-16; y=RNG.range(state.r,0,H);}
    const hp = 3 + ((state.time/30)|0);
    enemies.spawn(e=>{ e.x=x; e.y=y; e.hp=hp; e.maxHp=hp; e.t=0; });
  }

  // ====== Collision (Quadtree) ======
  const qt = new Quad(0,0,W,H,10,0,6);
  function collisionSystem(){
    qt.clear();
    enemies.each(e=>qt.insert(e));
    // bullets vs enemies
    bullets.each(b=>{
      if(b.team!==0) return;
      const range = {x:b.x-16,y:b.y-16,w:32,h:32};
      const cand=[]; qt.query(range,cand);
      for(const e of cand){
        const dx=e.x-b.x, dy=e.y-b.y; const rr=(e.r+b.r); if(dx*dx+dy*dy <= rr*rr){
          e.hp -= b.dmg; if(b.pierce>0){ b.pierce--; } else { bullets.release(b); break; }
          if(e.hp<=0){ enemies.release(e); state.score+=10; drops.spawn(d=>{ d.x=e.x; d.y=e.y; d.vx=RNG.range(state.r,-20,20); d.vy=RNG.range(state.r,-30,-10); d.kind='xp'; }); }
        }
      }
    });
    // enemy bullets vs player
    bullets.each(b=>{
      if(b.team!==1) return; const dx=player.x-b.x, dy=player.y-b.y; const rr=player.r+b.r; if(dx*dx+dy*dy<=rr*rr){ if(player.ifr<=0){ player.hp--; player.ifr=0.6; } bullets.release(b); }
    });
    // drops vs player
    drops.each(d=>{ const dx=player.x-d.x, dy=player.y-d.y; const rr=player.r+d.r; if(dx*dx+dy*dy<=rr*rr){ drops.release(d); state.xp++; if(state.xp>=state.nextLvl){ state.xp=0; state.lvl++; state.nextLvl = Math.floor(state.nextLvl*1.25); /* TODO: 레벨업 선택 UI */ } }
    });
  }

  function cleanupSystem(){
    drops.each(d=>{ d.vy += 30*FIXED_DT; d.x+=d.vx*FIXED_DT; d.y+=d.vy*FIXED_DT; if(d.y>H+20) drops.release(d); });
    if(player.hp<=0) state.alive=false;
  }

  // ====== Render ======
  function render(){
    ctx.clearRect(0,0,W,H);
    // background grid
    ctx.globalAlpha=0.15; ctx.strokeStyle='#223';
    for(let x=0;x<=W;x+=30){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0;y<=H;y+=30){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    ctx.globalAlpha=1;

    // drops
    ctx.fillStyle='#7dd3fc'; drops.each(d=>{ ctx.beginPath(); ctx.arc(d.x,d.y,d.r,0,TAU); ctx.fill(); });
    // bullets
    ctx.fillStyle='#fda4af'; bullets.each(b=>{ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,TAU); ctx.fill(); });
    // enemies
    ctx.fillStyle='#a7f3d0'; enemies.each(e=>{ ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,TAU); ctx.fill(); });
    // player
    if(player.ifr>0) ctx.globalAlpha=0.5; ctx.fillStyle='#fef3c7'; ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,TAU); ctx.fill(); ctx.globalAlpha=1;

    // UI
    const info = document.getElementById('info');
    info.textContent = `HP ${player.hp}/${player.maxHp} | XP ${state.xp}/${state.nextLvl} | LV ${state.lvl} | Score ${state.score}`;

    // HUD
    const hud = document.getElementById('hud');
    hud.textContent = `seed:${state.seed} time:${state.time.toFixed(1)} ents(b/e/d):${bullets.raw.length-bullets.free.length}/${enemies.raw.length-enemies.free.length}/${drops.raw.length-drops.free.length}`;
  }

  // ====== Main loop ======
  let acc=0, last=performance.now();
  function tick(now){ acc += Math.min(0.25,(now-last)/1000); last=now; while(acc>=FIXED_DT){ update(FIXED_DT); acc-=FIXED_DT; } render(); requestAnimationFrame(tick); }

  // ====== Save/Load ======
  function save(){ const payload={ best:Math.max(state.score, (load()?.best||0)), unlocks:load()?.unlocks||[], options:load()?.options||{}, lastSeed:state.seed }; localStorage.setItem('rbh_save', JSON.stringify(payload)); }
  function load(){ try{ return JSON.parse(localStorage.getItem('rbh_save')||'null'); }catch(e){ return null; } }

  // ====== UI Bindings ======
  document.getElementById('btnStart').onclick=()=>{ resetRun(); };
  document.getElementById('btnExport').onclick=()=>{ const s=localStorage.getItem('rbh_save')||'{}'; navigator.clipboard?.writeText(s); alert('저장 JSON을 클립보드에 복사했습니다.'); };
  document.getElementById('btnImport').onclick=()=>{ const s=prompt('저장 JSON 붙여넣기'); if(s){ try{ localStorage.setItem('rbh_save', s); alert('불러오기 완료'); }catch(e){ alert('잘못된 JSON'); } } };

  function resetRun(){ const seed=(load()?.lastSeed ?? (Date.now()|0)); state.seed=seed; state.r=XorShift32(seed); state.time=0; state.wave=1; state.xp=0; state.lvl=1; state.nextLvl=10; state.alive=true; state.score=0; player.hp=player.maxHp; bullets.raw.forEach(o=>o.alive=false); bullets.free.length=bullets.raw.length; enemies.raw.forEach(o=>o.alive=false); enemies.free.length=enemies.raw.length; drops.raw.forEach(o=>o.alive=false); drops.free.length=drops.raw.length; }

  // autostart preview
  resetRun(); requestAnimationFrame(tick);
  // expose for console debug
  Game.state=state; Game.player=player; Game.enemies=enemies; Game.bullets=bullets; Game.drops=drops; Game.save=save; Game.load=load;
})();
```

---

# 다음 단계 체크리스트

* [ ] 레벨업 **3중 선택 UI** 구현 및 태그/시너지 시스템 연결
* [ ] 적 아키타입(돌진, 회전, 소환, 레이저) 4종과 보스 1종
* [ ] 탄 패턴 모듈화: `emitCircle(n,speed,spread)`, `emitSpiral(rate,accel)` 등
* [ ] 무적 프레임 시각 피드백, 피격 화면 셰이크
* [ ] 드랍 **마그넷 흡입**(플레이어 반경 내 가속)
* [ ] 웨이브 타이머와 엘리트/보스 스케줄러
* [ ] 세이브: 언락, 옵션, 시드 기록. Export/Import UI 개선
* [ ] 성능: 쿼드트리 파라미터 튜닝, 풀 사이즈 상향, 드로우 배치 최적화

---

# 디버그 팁

* `window.Game` 노출 완료. 콘솔에서 `Game.state.seed=123;`로 재현.
* HUD에 FPS 측정 추가 필요 시 `performance.now()` 기반 이동 평균.
* 충돌 튜닝은 **반경(r)**로만 조절. 아트가 들어와도 물리 반경은 유지.

---

# 확장 아이디어

* 빌드 프리셋(시드에 따라 등장 확률 가중치)
* 그레이즈 점수, 타임 어택 보너스
* 난이도 선택: 체력 배수, 드랍률, 적 패턴 밀도
* 데일리 시드(당일 날짜 해시를 시드로)
